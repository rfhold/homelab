# LibreChat Implementation Plan

## Overview
This document provides a detailed implementation plan for integrating LibreChat into the AI workspace module. The implementation will deploy LibreChat API and RAG API using Docker images, with supporting infrastructure components managed by the module.

## Architecture Overview

### Component Structure
```
src/components/
├── meilisearch.ts          # Search engine for LibreChat
├── librechat.ts            # LibreChat API component
└── librechat-rag.ts        # LibreChat RAG API component

src/modules/ai-workspace.ts
├── Database Management
│   ├── DocumentDB (bitnami-postgres-documentdb)
│   └── PgVector (bitnami-postgres-pgvector)
├── Cache Management (Redis/Valkey)
├── Search Engine (Meilisearch)
├── LibreChat Components
│   ├── RAG API
│   └── Main API
├── Service Auto-Discovery
└── Provider Configuration
```

### Implementation Order
1. **Meilisearch Component** - Search engine
2. **Bitnami PostgreSQL DocumentDB** - Main database
3. **Bitnami PostgreSQL PgVector** - Vector database for RAG
4. **LibreChat RAG API** - RAG service
5. **LibreChat API** - Main application

## Configuration Requirements

### Core Environment Variables
```yaml
# Security Keys (Generated by Pulumi Random)
CREDS_KEY          # 32-byte key for credential encryption
CREDS_IV           # 16-byte initialization vector
JWT_SECRET         # JWT signing secret
JWT_REFRESH_SECRET # JWT refresh token secret
MEILI_MASTER_KEY   # Meilisearch master key

# Database (Module-managed)
DATABASE_URL       # DocumentDB connection string
RAG_DATABASE_URL   # PgVector connection string
REDIS_URL          # Redis/Valkey connection string

# Search
MEILI_URL          # Meilisearch URL (http://meilisearch:7700)

# Storage (defaults to local)
FILE_STRATEGY      # "local" by default
STORAGE_DIR        # /app/uploads (with PVC)

# Providers (Existing in module)
OPENAI_API_KEY     # OpenAI API key (from openaiConfig)
ANTHROPIC_API_KEY  # Anthropic API key (from anthropicConfig)
OPENROUTER_API_KEY # OpenRouter API key (from openrouterConfig)
JINAAI_API_KEY     # Jina AI API key (from jinaaiConfig)

# Service URLs (Auto-configured)
SEARXNG_URL        # SearXNG URL (if enabled)
FIRECRAWL_URL      # Firecrawl URL (if enabled)
```

### LibreChat YAML Configuration Structure
```yaml
version: 1.2.8
cache: true
fileStrategy: "local"  # Default to local storage

# File handling configuration
fileConfig:
  serverFileSizeLimit: 100  # MB
  avatarSizeLimit: 5        # MB
  clientImageResize:
    enabled: true
    maxWidth: 1920
    maxHeight: 1080
    quality: 0.8
    compressFormat: "jpeg"

# Rate limiting
rateLimits:
  fileUploads:
    userMax: 50
    userWindowInMinutes: 60
  stt:
    userMax: 100
    userWindowInMinutes: 1
  tts:
    userMax: 100
    userWindowInMinutes: 1

# Interface configuration
interface:
  modelSelect: true
  parameters: true
  sidePanel: true
  presets: true
  prompts: true
  bookmarks: true
  multiConvo: true
  agents: true
  webSearch: true
  fileSearch: true
  temporaryChatRetention: 720  # 30 days

# Registration settings
registration:
  socialLogins:
    - github
    - google
  allowedDomains:
    - "@example.com"

# Model specifications
modelSpecs:
  enforce: false
  prioritize: true
  list: []  # To be populated based on enabled providers

# Endpoints configuration
endpoints:
  custom: []  # Custom endpoints (Ollama, vLLM, etc.)
  assistants:
    enabled: false  # Future enhancement
  agents:
    enabled: true
    model: "gpt-4o"  # Default agent model
```

## Implementation Phases

### Phase 1: Infrastructure Components (Week 1)

#### 1.1 Meilisearch Component
```typescript
interface MeilisearchArgs {
  namespace: string;
  name?: string;
  
  // Core configuration
  masterKey: pulumi.Output<string>;
  environment?: "development" | "production";
  
  // Storage
  storage?: {
    size?: string;  // Default: "10Gi"
    storageClass?: string;
  };
  
  // Resources
  resources?: {
    limits?: {
      cpu?: string;
      memory?: string;
    };
    requests?: {
      cpu?: string;
      memory?: string;
    };
  };
}
```

Implementation:
```typescript
// src/components/meilisearch.ts
export class MeilisearchComponent extends pulumi.ComponentResource {
  public readonly service: k8s.core.v1.Service;
  public readonly url: pulumi.Output<string>;
  
  constructor(name: string, args: MeilisearchArgs, opts?: pulumi.ComponentResourceOptions) {
    // Deploy Meilisearch with PVC for data persistence
    // Create service for internal access
    // Return service URL for LibreChat configuration
  }
}
```

#### 1.2 Database Components (Module-Managed)
The AI workspace module will manage database provisioning:

```typescript
// In ai-workspace module
// DocumentDB for LibreChat
const documentDb = new BitnamiPostgresDocumentDB("librechat-db", {
  namespace: args.namespace,
  auth: {
    database: "librechat",
    username: "librechat",
    password: pulumi.secret(randomPassword.result),
  },
  storage: {
    size: "20Gi",
  },
});

// PgVector for RAG API
const pgVector = new BitnamiPostgresPgVector("librechat-rag-db", {
  namespace: args.namespace,
  auth: {
    database: "librechat_rag",
    username: "librechat_rag",
    password: pulumi.secret(randomPassword.result),
  },
  storage: {
    size: "50Gi",
  },
});
```

#### 1.3 Security Key Generation
```typescript
// Using Pulumi Random provider
const credsKey = new random.RandomPassword("creds-key", {
  length: 64,  // 32 bytes in hex
  special: false,
  upper: false,
});

const credsIV = new random.RandomPassword("creds-iv", {
  length: 32,  // 16 bytes in hex
  special: false,
  upper: false,
});

const jwtSecret = new random.RandomPassword("jwt-secret", {
  length: 32,
  special: true,
});

const jwtRefreshSecret = new random.RandomPassword("jwt-refresh-secret", {
  length: 32,
  special: true,
});

const meiliMasterKey = new random.RandomPassword("meili-master-key", {
  length: 32,
  special: true,
});
```

### Phase 2: LibreChat RAG API Component (Week 1-2)

#### 2.1 RAG API Component Interface
```typescript
interface LibreChatRagArgs {
  namespace: string;
  name?: string;
  
  // Docker image
  image?: string;  // Default: ghcr.io/danny-avila/librechat-rag-api-dev-lite:latest
  
  // Database connection
  database: {
    host: string;
    port?: number;
    name: string;
    username: string;
    password: pulumi.Output<string>;
  };
  
  // Vector configuration
  vectorStore?: {
    provider?: "pgvector";  // Default and only option for now
    embeddingModel?: string;  // Default: "text-embedding-3-small"
  };
  
  // OpenAI configuration
  openai: {
    apiKey: pulumi.Output<string>;
  };
  
  // Resources
  resources?: {
    limits?: {
      cpu?: string;
      memory?: string;
    };
    requests?: {
      cpu?: string;
      memory?: string;
    };
  };
}
```

#### 2.2 RAG API Implementation
```typescript
export class LibreChatRagComponent extends pulumi.ComponentResource {
  public readonly service: k8s.core.v1.Service;
  public readonly url: pulumi.Output<string>;
  
  constructor(name: string, args: LibreChatRagArgs, opts?: pulumi.ComponentResourceOptions) {
    // Deploy RAG API with environment variables
    // Configure PgVector connection
    // Set up OpenAI for embeddings
    // Create service for internal access
  }
}
```

Environment variables:
```yaml
env:
  - name: DATABASE_URL
    value: postgresql://user:pass@pgvector:5432/librechat_rag
  - name: VECTOR_DB_TYPE
    value: pgvector
  - name: OPENAI_API_KEY
    valueFrom:
      secretKeyRef:
        name: librechat-secrets
        key: openai-api-key
  - name: EMBEDDING_MODEL
    value: text-embedding-3-small
  - name: PORT
    value: "8000"
```

### Phase 3: LibreChat API Component (Week 2)

#### 3.1 LibreChat API Component Interface
```typescript
interface LibreChatArgs {
  namespace: string;
  name?: string;
  
  // Core configuration
  domain: string;
  image?: string;  // Default: ghcr.io/danny-avila/librechat:latest
  replicas?: number;
  
  // Database connections (from module)
  database: {
    host: string;
    port?: number;
    name: string;
    username: string;
    password: pulumi.Output<string>;
  };
  
  // Cache connection (from module)
  cache: {
    host: string;
    port?: number;
    password?: pulumi.Output<string>;
  };
  
  // Search engine
  meilisearch: {
    url: string;
    masterKey: pulumi.Output<string>;
  };
  
  // RAG API
  ragApi?: {
    url: string;
    apiKey?: pulumi.Output<string>;
  };
  
  // Storage configuration
  storage?: {
    type?: "local" | "s3";  // Default: "local"
    local?: {
      size?: string;  // Default: "10Gi"
      storageClass?: string;
    };
    s3?: {
      endpoint: string;
      bucket: string;
      accessKey: string;
      secretKey: pulumi.Output<string>;
    };
  };
  
  // Security keys (generated by module)
  security: {
    credsKey: pulumi.Output<string>;
    credsIV: pulumi.Output<string>;
    jwtSecret: pulumi.Output<string>;
    jwtRefreshSecret: pulumi.Output<string>;
  };
  
  // Provider configuration
  providers?: {
    openai?: {
      apiKey: pulumi.Output<string>;
    };
    anthropic?: {
      apiKey: pulumi.Output<string>;
    };
  };
  
  // LibreChat YAML config
  config?: any;  // Full librechat.yaml configuration
  
  // Resources
  resources?: {
    limits?: {
      cpu?: string;
      memory?: string;
    };
    requests?: {
      cpu?: string;
      memory?: string;
    };
  };
}
```

#### 3.2 LibreChat Deployment
```typescript
export class LibreChatComponent extends pulumi.ComponentResource {
  public readonly deployment: k8s.apps.v1.Deployment;
  public readonly service: k8s.core.v1.Service;
  public readonly ingress: k8s.networking.v1.Ingress;
  
  constructor(name: string, args: LibreChatArgs, opts?: pulumi.ComponentResourceOptions) {
    // Create ConfigMap with librechat.yaml
    // Deploy LibreChat with all environment variables
    // Set up persistent volume for local file storage
    // Create service and ingress
  }
}
```

#### 3.3 Environment Configuration
```yaml
env:
  # Database
  - name: DATABASE_URL
    value: postgresql://user:pass@documentdb:5432/librechat
  - name: REDIS_URL
    value: redis://:password@redis:6379
  
  # Search
  - name: MEILI_URL
    value: http://meilisearch:7700
  - name: MEILI_MASTER_KEY
    valueFrom:
      secretKeyRef:
        name: librechat-secrets
        key: meili-master-key
  
  # Security
  - name: CREDS_KEY
    valueFrom:
      secretKeyRef:
        name: librechat-secrets
        key: creds-key
  - name: CREDS_IV
    valueFrom:
      secretKeyRef:
        name: librechat-secrets
        key: creds-iv
  
  # Storage
  - name: FILE_STRATEGY
    value: "local"
  - name: STORAGE_DIR
    value: "/app/uploads"
  
  # RAG API
  - name: RAG_API_URL
    value: http://librechat-rag:8000
  
  # Providers (OpenAI for STT/TTS)
  - name: OPENAI_API_KEY
    valueFrom:
      secretKeyRef:
        name: librechat-secrets
        key: openai-api-key
```

### Phase 4: Module Integration (Week 2-3)

#### 4.1 AI Workspace Module Structure
```typescript
interface AIWorkspaceModuleArgs {
  namespace: pulumi.Input<string>;
  
  // LibreChat configuration (new)
  librechat?: {
    enabled?: pulumi.Input<boolean>;
    domain: pulumi.Input<string>;
    replicas?: pulumi.Input<number>;
    
    // STT/TTS configuration
    stt?: {
      implementation?: pulumi.Input<STTImplementation>;
    };
    tts?: {
      implementation?: pulumi.Input<TTSImplementation>;
    };
    
    // Storage configuration
    storage?: {
      type?: pulumi.Input<"local" | "s3">;
      size?: pulumi.Input<string>;  // For local storage
      s3?: {
        endpoint: pulumi.Input<string>;
        bucket: pulumi.Input<string>;
        accessKey: pulumi.Input<string>;
        secretKey: pulumi.Input<string>;
      };
    };
    
    // Resource limits
    resources?: {
      api?: {
        requests?: {
          memory?: pulumi.Input<string>;
          cpu?: pulumi.Input<string>;
        };
        limits?: {
          memory?: pulumi.Input<string>;
          cpu?: pulumi.Input<string>;
        };
      };
      rag?: {
        requests?: {
          memory?: pulumi.Input<string>;
          cpu?: pulumi.Input<string>;
        };
        limits?: {
          memory?: pulumi.Input<string>;
          cpu?: pulumi.Input<string>;
        };
      };
    };
    
    // Ingress configuration
    ingress?: {
      enabled?: pulumi.Input<boolean>;
      className?: pulumi.Input<string>;
      annotations?: pulumi.Input<{ [key: string]: string }>;
      tls?: {
        enabled?: pulumi.Input<boolean>;
        secretName?: pulumi.Input<string>;
      };
    };
  };
  
  // Existing provider configurations (already in module)
  openai?: {
    enabled?: pulumi.Input<boolean>;
    apiKey: pulumi.Input<string>;
    models?: pulumi.Input<string[]>;
    stt?: {
      model?: pulumi.Input<string>;
    };
    tts?: {
      model?: pulumi.Input<string>;
      voice?: pulumi.Input<string>;
    };
  };
  
  openrouter?: {
    enabled?: pulumi.Input<boolean>;
    apiKey: pulumi.Input<string>;
    models?: pulumi.Input<string[]>;
  };
  
  jinaai?: {
    enabled?: pulumi.Input<boolean>;
    apiKey: pulumi.Input<string>;
  };
  
  anthropic?: {
    enabled?: pulumi.Input<boolean>;
    apiKey: pulumi.Input<string>;
    models?: pulumi.Input<string[]>;
  };
  
  // Existing services
  searxng?: {
    // ... existing interface
  };
  
  firecrawl?: {
    // ... existing interface
  };
}
```

#### 4.2 Module Implementation
```typescript
export class AIWorkspaceModule extends pulumi.ComponentResource {
  // Add new properties for LibreChat
  private readonly librechatValkey?: Valkey;
  private readonly meilisearch?: Meilisearch;
  private readonly documentDb?: BitnamiPostgresDocumentDB;
  private readonly pgVector?: BitnamiPostgresPgVector;
  private readonly librechatRag?: LibreChatRag;
  private readonly librechat?: LibreChat;
  
  // Existing properties
  private readonly valkey?: Valkey;
  private readonly firecrawlValkey?: Valkey;
  public readonly searxng?: SearXNG;
  public readonly firecrawl?: Firecrawl;
  
  // Existing provider configs
  public readonly openaiConfig?: {
    apiKey: pulumi.Output<string>;
    models: pulumi.Output<string[]>;
    stt: {
      model: pulumi.Output<string>;
    };
    tts: {
      model: pulumi.Output<string>;
      voice: pulumi.Output<string>;
    };
  };
  public readonly openrouterConfig?: {
    apiKey: pulumi.Output<string>;
    models: pulumi.Output<string[]>;
  };
  public readonly jinaaiConfig?: {
    apiKey: pulumi.Output<string>;
  };
  public readonly anthropicConfig?: {
    apiKey: pulumi.Output<string>;
    models: pulumi.Output<string[]>;
  };
  
  constructor(name: string, args: AIWorkspaceModuleArgs, opts?: pulumi.ComponentResourceOptions) {
    super("homelab:modules:AIWorkspace", name, {}, opts);
    
    const defaultResourceOptions: pulumi.ResourceOptions = { parent: this };
    
    // Existing provider configuration (openai, openrouter, jinaai, anthropic)
    // ... (keep existing code)
    
    // LibreChat deployment
    if (args.librechat?.enabled) {
      // 1. Generate security keys
      const keys = this.generateSecurityKeys();
      
      // 2. Deploy cache for LibreChat
      this.librechatValkey = new Valkey(`${name}-librechat-cache`, {
        namespace: args.namespace,
        storage: {
          size: "4Gi",
        },
        memoryLimit: "512Mi",
        cpuLimit: "250m",
      }, defaultResourceOptions);
      
      // 3. Deploy Meilisearch
      this.meilisearch = new MeilisearchComponent(`${name}-meilisearch`, {
        namespace: args.namespace,
        masterKey: keys.meiliMasterKey,
        storage: {
          size: "10Gi",
        },
      }, defaultResourceOptions);
      
      // 4. Deploy databases
      this.documentDb = new BitnamiPostgresDocumentDB(`${name}-librechat-db`, {
        namespace: args.namespace,
        auth: {
          database: "librechat",
          username: "librechat",
          password: pulumi.secret(new random.RandomPassword(`${name}-db-password`, {
            length: 32,
            special: true,
          }).result),
        },
        storage: {
          size: "20Gi",
        },
      }, defaultResourceOptions);
      
      this.pgVector = new BitnamiPostgresPgVector(`${name}-rag-db`, {
        namespace: args.namespace,
        auth: {
          database: "librechat_rag",
          username: "librechat_rag",
          password: pulumi.secret(new random.RandomPassword(`${name}-rag-db-password`, {
            length: 32,
            special: true,
          }).result),
        },
        storage: {
          size: "50Gi",
        },
      }, defaultResourceOptions);
      
      // 5. Deploy RAG API (requires OpenAI)
      if (this.openaiConfig) {
        this.librechatRag = new LibreChatRagComponent(`${name}-rag-api`, {
          namespace: args.namespace,
          database: {
            host: this.pgVector.service.metadata.name,
            port: 5432,
            name: "librechat_rag",
            username: "librechat_rag",
            password: this.pgVector.auth.password,
          },
          openai: {
            apiKey: this.openaiConfig.apiKey,
          },
        }, {
          dependsOn: [this.pgVector],
          ...defaultResourceOptions,
        });
      }
      
      // 6. Deploy LibreChat API
      const valkeyConfig = this.librechatValkey.getConnectionConfig();
      const redisUrl = createRedisConnectionString(valkeyConfig);
      
      this.librechat = new LibreChatComponent(`${name}-librechat`, {
        namespace: args.namespace,
        domain: args.librechat.domain,
        replicas: args.librechat.replicas,
        database: {
          host: this.documentDb.service.metadata.name,
          port: 5432,
          name: "librechat",
          username: "librechat",
          password: this.documentDb.auth.password,
        },
        cache: {
          url: redisUrl,
        },
        meilisearch: {
          url: pulumi.interpolate`http://${this.meilisearch.service.metadata.name}:7700`,
          masterKey: keys.meiliMasterKey,
        },
        ragApi: this.librechatRag ? {
          url: pulumi.interpolate`http://${this.librechatRag.service.metadata.name}:8000`,
        } : undefined,
        security: {
          credsKey: keys.credsKey,
          credsIV: keys.credsIV,
          jwtSecret: keys.jwtSecret,
          jwtRefreshSecret: keys.jwtRefreshSecret,
        },
        providers: {
          openai: this.openaiConfig,
          anthropic: this.anthropicConfig,
          openrouter: this.openrouterConfig,
          jinaai: this.jinaaiConfig,
        },
        storage: args.librechat.storage,
        resources: args.librechat.resources,
        ingress: args.librechat.ingress,
        config: this.generateLibreChatConfig(args),
      }, {
        dependsOn: [
          this.librechatValkey,
          this.meilisearch,
          this.documentDb,
          ...(this.librechatRag ? [this.librechatRag] : []),
        ],
        ...defaultResourceOptions,
      });
    }
    
    // Existing searxng and firecrawl code...
  }
}
```

### Phase 5: Configuration & Testing (Week 3)

#### 5.1 LibreChat YAML Generation
The module will generate the librechat.yaml configuration based on enabled services:

```typescript
private generateLibreChatConfig(args: AIWorkspaceModuleArgs): any {
  const config: any = {
    version: "1.2.8",
    cache: true,
    fileStrategy: args.librechat?.storage?.type || "local",
    
    // File configuration
    fileConfig: {
      serverFileSizeLimit: 100,
      avatarSizeLimit: 5,
      clientImageResize: {
        enabled: true,
        maxWidth: 1920,
        maxHeight: 1080,
        quality: 0.8,
        compressFormat: "jpeg",
      },
    },
    
    // Rate limits
    rateLimits: {
      fileUploads: {
        userMax: 50,
        userWindowInMinutes: 60,
      },
      stt: {
        userMax: 100,
        userWindowInMinutes: 1,
      },
      tts: {
        userMax: 100,
        userWindowInMinutes: 1,
      },
    },
    
    // Interface
    interface: {
      modelSelect: true,
      parameters: true,
      sidePanel: true,
      presets: true,
      prompts: true,
      bookmarks: true,
      multiConvo: true,
      agents: true,
      webSearch: !!this.searxng,  // Enable if SearXNG is deployed
      fileSearch: !!this.librechatRag,  // Enable if RAG API is deployed
      temporaryChatRetention: 720,
    },
    
    // Endpoints configuration
    endpoints: {},
  };
  
  // Configure speech based on implementation selection
  const sttImpl = args.librechat?.stt?.implementation || STTImplementation.OPENAI;
  const ttsImpl = args.librechat?.tts?.implementation || TTSImplementation.OPENAI;
  
  if (sttImpl === STTImplementation.OPENAI && this.openaiConfig) {
    config.speech = config.speech || {};
    config.speech.stt = {
      openai: {
        url: "/v1/audio/transcriptions",
        model: this.openaiConfig.stt.model,
      },
    };
  }
  
  if (ttsImpl === TTSImplementation.OPENAI && this.openaiConfig) {
    config.speech = config.speech || {};
    config.speech.tts = {
      openai: {
        url: "/v1/audio/speech",
        model: this.openaiConfig.tts.model,
        voices: ["alloy", "echo", "fable", "onyx", "nova", "shimmer"],
      },
    };
  }
  
  // Configure model endpoints
  if (this.openaiConfig) {
    config.endpoints.openAI = {
      models: {
        default: this.openaiConfig.models,
      },
      titleModel: "gpt-4o-mini",
      streamRate: 25,
    };
  }
  
  if (this.anthropicConfig) {
    config.endpoints.anthropic = {
      models: {
        default: this.anthropicConfig.models,
      },
      titleModel: "claude-3-5-haiku-20241022",
    };
  }
  
  if (this.openrouterConfig) {
    config.endpoints.custom = config.endpoints.custom || [];
    config.endpoints.custom.push({
      name: "OpenRouter",
      apiKey: "${OPENROUTER_API_KEY}",
      baseURL: "https://openrouter.ai/api/v1",
      models: {
        default: this.openrouterConfig.models,
      },
      titleModel: "openai/gpt-4o-mini",
    });
  }
  
  // Configure web search if enabled
  if (this.searxng) {
    config.webSearch = {
      searchProvider: "searxng",
      searxngInstanceUrl: "${SEARXNG_URL}",
    };
  }
  
  if (this.firecrawl) {
    config.webSearch = config.webSearch || {};
    config.webSearch.scraperType = "firecrawl";
    config.webSearch.firecrawlApiUrl = "${FIRECRAWL_URL}";
  }
  
  if (this.jinaaiConfig) {
    config.webSearch = config.webSearch || {};
    config.webSearch.rerankerType = "jina";
    config.webSearch.jinaApiKey = "${JINAAI_API_KEY}";
  }
  
  return config;
}
```

#### 5.2 Testing Checklist
- [ ] Meilisearch deployment and connectivity
- [ ] DocumentDB provisioning and migrations
- [ ] PgVector provisioning and schema
- [ ] RAG API deployment and vector operations
- [ ] LibreChat API deployment and UI access
- [ ] File upload/download (local storage)
- [ ] OpenAI STT transcription
- [ ] OpenAI TTS generation
- [ ] RAG document upload and search
- [ ] End-to-end conversation flow

## Component Implementation Details

### Meilisearch Component
```typescript
// src/components/meilisearch.ts
import * as pulumi from "@pulumi/pulumi";
import * as k8s from "@pulumi/kubernetes";

export class MeilisearchComponent extends pulumi.ComponentResource {
  public readonly service: k8s.core.v1.Service;
  public readonly url: pulumi.Output<string>;
  
  constructor(name: string, args: MeilisearchArgs, opts?: pulumi.ComponentResourceOptions) {
    super("homelab:components:Meilisearch", name, {}, opts);
    
    const labels = { app: name };
    
    // PVC for data persistence
    const pvc = new k8s.core.v1.PersistentVolumeClaim(`${name}-data`, {
      metadata: {
        namespace: args.namespace,
        labels,
      },
      spec: {
        accessModes: ["ReadWriteOnce"],
        storageClassName: args.storage?.storageClass,
        resources: {
          requests: {
            storage: args.storage?.size || "10Gi",
          },
        },
      },
    }, { parent: this });
    
    // Deployment
    const deployment = new k8s.apps.v1.Deployment(name, {
      metadata: {
        namespace: args.namespace,
        labels,
      },
      spec: {
        replicas: 1,
        selector: { matchLabels: labels },
        template: {
          metadata: { labels },
          spec: {
            containers: [{
              name: "meilisearch",
              image: "getmeili/meilisearch:v1.11",
              env: [
                { name: "MEILI_MASTER_KEY", value: args.masterKey },
                { name: "MEILI_ENV", value: args.environment || "production" },
                { name: "MEILI_DB_PATH", value: "/meili_data" },
              ],
              ports: [{ containerPort: 7700 }],
              volumeMounts: [{
                name: "data",
                mountPath: "/meili_data",
              }],
              resources: args.resources,
            }],
            volumes: [{
              name: "data",
              persistentVolumeClaim: { claimName: pvc.metadata.name },
            }],
          },
        },
      },
    }, { parent: this });
    
    // Service
    this.service = new k8s.core.v1.Service(name, {
      metadata: {
        namespace: args.namespace,
        labels,
      },
      spec: {
        selector: labels,
        ports: [{
          port: 7700,
          targetPort: 7700,
        }],
      },
    }, { parent: this });
    
    this.url = pulumi.interpolate`http://${this.service.metadata.name}:7700`;
  }
}
```

### LibreChat RAG API Component
```typescript
// src/components/librechat-rag.ts
export class LibreChatRagComponent extends pulumi.ComponentResource {
  public readonly service: k8s.core.v1.Service;
  public readonly url: pulumi.Output<string>;
  
  constructor(name: string, args: LibreChatRagArgs, opts?: pulumi.ComponentResourceOptions) {
    super("homelab:components:LibreChatRag", name, {}, opts);
    
    const labels = { app: name };
    
    // Database URL construction
    const databaseUrl = pulumi.interpolate`postgresql://${args.database.username}:${args.database.password}@${args.database.host}:${args.database.port || 5432}/${args.database.name}`;
    
    // Deployment
    const deployment = new k8s.apps.v1.Deployment(name, {
      metadata: {
        namespace: args.namespace,
        labels,
      },
      spec: {
        replicas: 1,
        selector: { matchLabels: labels },
        template: {
          metadata: { labels },
          spec: {
            containers: [{
              name: "rag-api",
              image: args.image || "ghcr.io/danny-avila/librechat-rag-api-dev-lite:latest",
              env: [
                { name: "DATABASE_URL", value: databaseUrl },
                { name: "VECTOR_DB_TYPE", value: args.vectorStore?.provider || "pgvector" },
                { name: "OPENAI_API_KEY", value: args.openai.apiKey },
                { name: "EMBEDDING_MODEL", value: args.vectorStore?.embeddingModel || "text-embedding-3-small" },
                { name: "PORT", value: "8000" },
                { name: "ENV", value: "production" },
              ],
              ports: [{ containerPort: 8000 }],
              resources: args.resources,
            }],
          },
        },
      },
    }, { parent: this });
    
    // Service
    this.service = new k8s.core.v1.Service(name, {
      metadata: {
        namespace: args.namespace,
        labels,
      },
      spec: {
        selector: labels,
        ports: [{
          port: 8000,
          targetPort: 8000,
        }],
      },
    }, { parent: this });
    
    this.url = pulumi.interpolate`http://${this.service.metadata.name}:8000`;
  }
}
```

## Docker Images

### Official Images
- **Meilisearch**: `getmeili/meilisearch:v1.11`
- **LibreChat API**: `ghcr.io/danny-avila/librechat:latest`
- **LibreChat RAG API**: `ghcr.io/danny-avila/librechat-rag-api-dev-lite:latest`

### Custom Images (from docker/ directory)
- **DocumentDB**: Built from `docker/bitnami-postgres-documentdb/`
- **PgVector**: Built from `docker/bitnami-postgres-pgvector/`

## Testing Strategy

### Component Tests
1. **Meilisearch**
   - [ ] Deployment successful
   - [ ] Master key authentication working
   - [ ] Data persistence verified
   - [ ] Search operations functional

2. **DocumentDB**
   - [ ] Database provisioned
   - [ ] Connection string valid
   - [ ] LibreChat can connect
   - [ ] Schema migrations successful

3. **PgVector**
   - [ ] Database provisioned
   - [ ] Vector extension enabled
   - [ ] RAG API can connect
   - [ ] Embedding storage working

4. **RAG API**
   - [ ] Service accessible
   - [ ] Database connection established
   - [ ] OpenAI embeddings working
   - [ ] Document upload successful
   - [ ] Vector search functional

5. **LibreChat API**
   - [ ] Service accessible
   - [ ] All database connections working
   - [ ] Meilisearch integration functional
   - [ ] RAG API connection established
   - [ ] File uploads working (local storage)
   - [ ] OpenAI STT/TTS functional
   - [ ] UI fully accessible

### Integration Tests
- [ ] End-to-end conversation flow
- [ ] Document upload and RAG search
- [ ] Voice input (STT) to text
- [ ] Text to voice output (TTS)
- [ ] File persistence and retrieval
- [ ] Search functionality across conversations

## Security Considerations

### Key Management with Pulumi
```typescript
// All keys generated using Pulumi Random provider
import * as random from "@pulumi/random";

// Example key generation in module
private generateSecurityKeys() {
  return {
    credsKey: new random.RandomPassword("creds-key", {
      length: 64,
      special: false,
      upper: false,
    }).result,
    
    credsIV: new random.RandomPassword("creds-iv", {
      length: 32,
      special: false,
      upper: false,
    }).result,
    
    jwtSecret: new random.RandomPassword("jwt-secret", {
      length: 32,
      special: true,
    }).result,
    
    jwtRefreshSecret: new random.RandomPassword("jwt-refresh-secret", {
      length: 32,
      special: true,
    }).result,
    
    meiliMasterKey: new random.RandomPassword("meili-master-key", {
      length: 32,
      special: true,
    }).result,
  };
}
```

### Secret Storage
- All secrets stored as Kubernetes secrets
- Pulumi manages secret lifecycle
- Automatic encryption at rest
- No manual key generation required

### Network Security
1. Internal service communication only
2. TLS termination at ingress
3. No external database exposure
4. Service-to-service authentication via API keys

## Monitoring & Observability

### Metrics to Track
- Request latency
- Model usage by provider
- File upload statistics
- Error rates by endpoint
- User activity patterns

### Logging Strategy
- Structured JSON logging
- Log aggregation with Loki (future)
- Error tracking and alerting
- Audit logs for compliance

## Rollout Strategy

### Development Environment
1. Deploy basic configuration
2. Test core functionality
3. Enable advanced features
4. Validate integrations

### Staging Environment
1. Full feature deployment
2. Load testing
3. Security scanning
4. User acceptance testing

### Production Environment
1. Gradual rollout (canary deployment)
2. Monitor metrics closely
3. Quick rollback capability
4. Documentation updates

## Usage Examples

### Basic AI Workspace with OpenAI
```typescript
// In stacks/ai-workspace/index.ts
import { AIWorkspaceModule, STTImplementation, TTSImplementation } from "../../src/modules/ai-workspace";

const config = new pulumi.Config();

const aiWorkspace = new AIWorkspaceModule("ai-workspace", {
  namespace: "ai",
  
  // Enable LibreChat with OpenAI STT/TTS
  librechat: {
    enabled: true,
    domain: "chat.example.com",
    stt: {
      implementation: STTImplementation.OPENAI,
    },
    tts: {
      implementation: TTSImplementation.OPENAI,
    },
  },
  
  // OpenAI configuration (existing pattern)
  openai: {
    enabled: true,
    apiKey: config.requireSecret("openai-api-key"),
    models: ["gpt-4o", "gpt-4o-mini", "o1", "o1-mini"],
    stt: {
      model: "whisper-1",
    },
    tts: {
      model: "tts-1-hd",
      voice: "alloy",
    },
  },
});

export const librechatUrl = aiWorkspace.librechat?.url;
export const ragApiUrl = aiWorkspace.librechatRag?.url;
```

### Production Configuration with Multiple Providers
```typescript
const config = new pulumi.Config();

const aiWorkspace = new AIWorkspaceModule("ai-workspace", {
  namespace: "ai",
  
  // LibreChat with production settings
  librechat: {
    enabled: true,
    domain: "chat.company.com",
    replicas: 3,
    
    stt: {
      implementation: STTImplementation.OPENAI,
    },
    tts: {
      implementation: TTSImplementation.OPENAI,
    },
    
    storage: {
      type: "s3",
      s3: {
        endpoint: "https://s3.company.com",
        bucket: "librechat-prod",
        accessKey: "librechat",
        secretKey: config.requireSecret("s3-secret-key"),
      },
    },
    
    resources: {
      api: {
        limits: {
          cpu: "4000m",
          memory: "8Gi",
        },
        requests: {
          cpu: "1000m",
          memory: "2Gi",
        },
      },
      rag: {
        limits: {
          cpu: "2000m",
          memory: "4Gi",
        },
        requests: {
          cpu: "500m",
          memory: "1Gi",
        },
      },
    },
    
    ingress: {
      enabled: true,
      className: "nginx",
      tls: {
        enabled: true,
        secretName: "librechat-tls",
      },
    },
  },
  
  // Multiple AI providers (existing pattern)
  openai: {
    enabled: true,
    apiKey: config.requireSecret("openai-api-key"),
    models: ["gpt-4o", "gpt-4o-mini"],
  },
  
  anthropic: {
    enabled: true,
    apiKey: config.requireSecret("anthropic-api-key"),
    models: ["claude-3-5-sonnet-20241022", "claude-3-5-haiku-20241022"],
  },
  
  openrouter: {
    enabled: true,
    apiKey: config.requireSecret("openrouter-api-key"),
  },
  
  // Enable search and scraping
  searxng: {
    enabled: true,
    ingress: {
      enabled: false,  // Internal use only
    },
  },
  
  firecrawl: {
    enabled: true,
    provider: {
      type: FirecrawlProvider.OPENAI,
      // Uses OpenAI API key from openai config
    },
  },
  
  jinaai: {
    enabled: true,
    apiKey: config.requireSecret("jinaai-api-key"),
  },
});
```

## Implementation Timeline

### Week 1: Core Components
1. **Day 1-2**: Meilisearch Component
   - Create component interface
   - Implement deployment logic
   - Add persistence configuration
   - Test deployment

2. **Day 3-4**: Database Setup in Module
   - Integrate bitnami-postgres-documentdb
   - Integrate bitnami-postgres-pgvector
   - Configure connection strings
   - Test connectivity

3. **Day 5**: RAG API Component
   - Create component interface
   - Implement deployment with PgVector connection
   - Configure OpenAI integration
   - Test vector operations

### Week 2: LibreChat Integration
1. **Day 1-2**: LibreChat API Component
   - Create component interface
   - Implement deployment logic
   - Configure all environment variables
   - Set up local storage PVC

2. **Day 3-4**: Module Integration
   - Create AI workspace module
   - Implement security key generation
   - Wire up all components
   - Configure librechat.yaml generation

3. **Day 5**: Testing & Documentation
   - End-to-end testing
   - Update component documentation
   - Create usage examples

### Week 3: Production Readiness
1. **Ingress and TLS configuration**
2. **Resource tuning and limits**
3. **Monitoring setup (future)**
4. **Backup strategies (future)**

## Next Steps

1. **Create Component Files**
   ```bash
   touch src/components/meilisearch.ts
   touch src/components/librechat.ts
   touch src/components/librechat-rag.ts
   ```

2. **Update Module Structure**
   - Extend ai-workspace module interface
   - Add database provisioning logic
   - Implement component orchestration

3. **Configure Stack**
   ```bash
   cd stacks/ai-workspace
   pulumi config set openai-api-key --secret
   ```

4. **Deploy Infrastructure**
   ```bash
   pulumi up
   ```

## Environment Variables Reference

### LibreChat API
| Variable | Description | Source |
|----------|-------------|--------|
| DATABASE_URL | PostgreSQL connection | Module-generated |
| REDIS_URL | Redis connection | Module-generated |
| MEILI_URL | Meilisearch URL | Component output |
| MEILI_MASTER_KEY | Meilisearch auth | Pulumi Random |
| RAG_API_URL | RAG API endpoint | Component output |
| CREDS_KEY | Encryption key | Pulumi Random |
| CREDS_IV | Encryption IV | Pulumi Random |
| JWT_SECRET | JWT signing | Pulumi Random |
| JWT_REFRESH_SECRET | JWT refresh | Pulumi Random |
| OPENAI_API_KEY | OpenAI API | User config |
| FILE_STRATEGY | Storage type | Config (default: local) |

### RAG API
| Variable | Description | Source |
|----------|-------------|--------|
| DATABASE_URL | PgVector connection | Module-generated |
| VECTOR_DB_TYPE | Vector DB type | Fixed: "pgvector" |
| OPENAI_API_KEY | OpenAI API | User config |
| EMBEDDING_MODEL | Embedding model | Config (default: text-embedding-3-small) |