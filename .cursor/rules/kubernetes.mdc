---
alwaysApply: false
description: "Defines patterns and best practices for Kubernetes resource management, Helm chart deployment, storage configuration, security, and K3s-specific configurations. Applies to all Kubernetes-related code and infrastructure."
---
# Kubernetes & Container Rules

## Helm Chart Management
- Centralize all Helm chart configurations in `src/helm-charts.ts`
- Use `HELM_CHARTS.COMPONENT_NAME` pattern for chart references
- Always use `createHelmChartArgs()` helper for OCI chart compatibility
- Use `k8s.helm.v4.Chart` for all Helm deployments
- Version pin all charts for reproducibility

## Resource Naming
- Use consistent naming patterns across Kubernetes resources
- Use `pulumi.interpolate` for dynamic resource names
- Follow Kubernetes naming conventions (DNS-1123 subdomain)
- Use descriptive names that indicate purpose and environment

## Namespace Management
- Always specify namespace for namespaced resources
- Use consistent namespace naming patterns
- Consider namespace isolation for different environments
- Don't hardcode namespaces - make them configurable

## Storage Patterns
- Use `StorageConfig` interface from adapters for consistent PVC configuration
- Use `createPVCSpec()` for embedding PVC specs in StatefulSets
- Use `createPVC()` for standalone PVC resources
- Always specify storage class when needed
- Use appropriate access modes for workload requirements

## Configuration Management
- Use ConfigMaps for non-sensitive configuration
- Use Secrets for sensitive data
- Use environment variables for service configuration
- Follow the adapter pattern for generating environment variables
- Use proper secret management practices

## Security Patterns
- Use connection-safe password generation
- Avoid hardcoded credentials
- Use proper RBAC where needed
- Follow principle of least privilege
- Use secure defaults for container configurations

## Service Mesh & Networking
- Use consistent service naming patterns
- Configure appropriate service types (ClusterIP, LoadBalancer, etc.)
- Use Ingress resources for external access
- Follow network policy best practices where applicable

## Monitoring & Observability
- Include appropriate labels for monitoring
- Use consistent annotation patterns
- Configure health checks (liveness/readiness probes)
- Include resource limits and requests

## K3s Specific Patterns
- Disable default components that will be replaced (servicelb, traefik, local-storage)
- Use appropriate node taints and tolerations
- Configure appropriate data directories
- Use cluster-init for bootstrap node setup
# Kubernetes & Container Rules

## Helm Chart Management
- Centralize all Helm chart configurations in `src/helm-charts.ts`
- Use `HELM_CHARTS.COMPONENT_NAME` pattern for chart references
- Always use `createHelmChartArgs()` helper for OCI chart compatibility
- Use `k8s.helm.v4.Chart` for all Helm deployments
- Version pin all charts for reproducibility

## Resource Naming
- Use consistent naming patterns across Kubernetes resources
- Use `pulumi.interpolate` for dynamic resource names
- Follow Kubernetes naming conventions (DNS-1123 subdomain)
- Use descriptive names that indicate purpose and environment

## Namespace Management
- Always specify namespace for namespaced resources
- Use consistent namespace naming patterns
- Consider namespace isolation for different environments
- Don't hardcode namespaces - make them configurable

## Storage Patterns
- Use `StorageConfig` interface from adapters for consistent PVC configuration
- Use `createPVCSpec()` for embedding PVC specs in StatefulSets
- Use `createPVC()` for standalone PVC resources
- Always specify storage class when needed
- Use appropriate access modes for workload requirements

## Configuration Management
- Use ConfigMaps for non-sensitive configuration
- Use Secrets for sensitive data
- Use environment variables for service configuration
- Follow the adapter pattern for generating environment variables
- Use proper secret management practices

## Security Patterns
- Use connection-safe password generation
- Avoid hardcoded credentials
- Use proper RBAC where needed
- Follow principle of least privilege
- Use secure defaults for container configurations

## Service Mesh & Networking
- Use consistent service naming patterns
- Configure appropriate service types (ClusterIP, LoadBalancer, etc.)
- Use Ingress resources for external access
- Follow network policy best practices where applicable

## Monitoring & Observability
- Include appropriate labels for monitoring
- Use consistent annotation patterns
- Configure health checks (liveness/readiness probes)
- Include resource limits and requests

## K3s Specific Patterns
- Disable default components that will be replaced (servicelb, traefik, local-storage)
- Use appropriate node taints and tolerations
- Configure appropriate data directories
- Use cluster-init for bootstrap node setup
